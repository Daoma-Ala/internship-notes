üé≠ **Clase #14: Try and Catch 14/21** üé≠  

En esta clase vamos a implementar lo aprendido de **async/await** usando la API y una nueva estructura con **try/catch**.  

üö® **Importante recordar que la estructura de async/await se compone por las palabras reservadas async y await:**  

- La palabra **async** se coloca antes de la funci√≥n (tambi√©n puede usarse con funciones flecha, en ese caso **async** va antes de los argumentos).  
- La palabra **await** se utiliza dentro de las funciones **async**.  

üñáÔ∏è **Otra forma de hacer que async/await espere a varios llamados a la vez es con la estructura: Try / Catch**  

- La palabra reservada **try** consiste en un bloque que contiene una o m√°s sentencias.  
- Su cuerpo est√° conformado por llaves `{}` y estas deben utilizarse siempre, incluso para un bloque de una sola sentencia.  
- Tambi√©n puede estar presente un bloque con la palabra reservada **catch**.  
- Un bloque **catch** es opcional (similar a c√≥mo us√°bamos **reject**) y contiene sentencias que especifican qu√© hacer si se lanza una excepci√≥n en el bloque **try**.  
- Si no se lanza ninguna excepci√≥n en el bloque **try**, el bloque **catch** se omite.  

‚úèÔ∏è **Ejemplo:**  
La estructura **try / catch** se asemeja a **if / else**, solo que **catch** puede detectar un error en caso de que haya uno:

```js
const anotherFunction = async (url_api) => {
    try {

    } catch (error) {

    }
}
```

üõ†Ô∏è **Siguiendo con el proyecto:**

1. Ir a VSC y crear en `src/async` el archivo **challenge.js**.

```js
import fetch from 'node-fetch';
const API = 'https://api.escuelajs.co/api/v1';

// L√≥gica de async: ir por los datos, luego esperar por ellos y finalmente retornarlos hacia el usuario
async function fetchData(urlApi) { // siempre async antes de function
    const response = await fetch(urlApi); // hacemos uso de fetch()
    const data = await response.json(); // estructura de los datos transform√°ndolos en json
    return data; // retorna la informaci√≥n de la API que estamos solicitando
}

// Tambi√©n se puede colocar la palabra async antes del argumento y se usa arrow function
const anotherFunction = async (urlApi) => {
    // En try estar√° todo lo que queremos que suceda con la l√≥gica de la aplicaci√≥n
    try {
        const products = await fetchData(`${urlApi}/products`);
        const product = await fetchData(`${urlApi}/products/${products[0].id}`);
        const category = await fetchData(`${urlApi}/categories/${product.category.id}`);

        console.log(products);
        console.log(product.title);
        console.log(category.name);
    } catch (error) { // Atraparemos un error en caso de que haya uno
        console.error(error);
    }
}

anotherFunction(API); // se hace el llamado
```

üñ•Ô∏è **Salida de `src/async/challenge.js`**

- Cuando se ejecuta `console.log(products);`, en `fetchData` se solicitan todos los productos de la API con `${urlApi}/products`. En la consola veremos una lista de productos dentro de un arreglo `[]`, cada uno representado por un objeto `{}`.
    
- Cuando se ejecuta `console.log(product.title);`, en `fetchData` se solicita el t√≠tulo de un producto en particular accediendo al atributo `title`.
    
    - Se usa `${urlApi}/products/${products[0].id}`, donde `0` indica la posici√≥n del primer producto en la lista obtenida anteriormente.
    - Es **importante** incluir `.id`, ya que si solo colocamos `${urlApi}/products/${products[0]}`, generar√≠a un error del tipo:  
        **TypeError: Cannot read properties of undefined (reading 'id')**.
- Cuando se ejecuta `console.log(category.name);`, en `fetchData` se solicita el nombre de la categor√≠a correspondiente al producto llamado anteriormente.
    
    - Se usa `${urlApi}/categories/${product.category.id}` y no es necesario indicar la posici√≥n, ya que cada producto solo tiene una categor√≠a.