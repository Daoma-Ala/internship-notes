
# Integración de DuckyCRM usando postMessage

	Como mencionamos anteriormente, el método `uriCallback` discutido en la lección anterior no funcionará para muchos CRMs. La razón es que los CRMs generalmente no admiten la apertura directa de páginas de perfil utilizando parámetros de consulta en la URL. Incluso si eso funciona, puede no ser una buena idea simplemente cambiar páginas en un iframe sin ninguna sincronización con el CRM en sí.
	
Imagina que estás en medio de la actualización de los detalles de un cliente en el CRM cuando llega una nueva tarea de chat. Solo deseas reconocer la nueva tarea y hacerle saber al cliente que estarás con ellos en un momento. Pero al hacer clic en la nueva tarea, has cargado la URL de su perfil y perdido todos los cambios que habías hecho en el anterior.

Por lo tanto, algunos CRMs vienen con sus propios SDKs de JavaScript para facilitar su integración en iframes de manera inteligente. Y si tienes un CRM desarrollado internamente, es fácil agregar una capa de este tipo utilizando `postMessage`.

## `postMessage`

`Window.postMessage()` es un método para la comunicación segura entre objetos `Window`, por ejemplo, entre una página y un iframe incrustado en ella. Si, por ejemplo, la página principal desea actualizar la página incrustada, simplemente llama al método `postMessage()` del iframe y le pasa algunos datos como parámetro.

La página incrustada puede suscribirse al evento `MessageEvent`, que se activará cada vez que se le envíe un mensaje. Si se trata de un CRM, puede, por ejemplo, guardar cualquier trabajo no guardado y cambiar correctamente al perfil del cliente solicitado.

Los siguientes diagramas ilustran las diferencias entre los dos métodos, es decir, cargar una nueva página con cada actualización frente a actualizar el contenido de la página dinámicamente:

![[Pasted image 20250210205324.png]]

## Implementación

Implementemos esto ahora. DuckyCRM tiene una versión de aplicación de una sola página (SPA) en esta URL:


https://duckycrm-7409-dev.twil.io/spa.html


No sería posible integrarla usando `uriCallback`, ya que la URL no cambia, así que usemos `postMessage` en su lugar. La versión SPA de DuckyCRM escucha mensajes que contienen el parámetro `id`, que representa el número de cuenta del perfil que se debe mostrar.

Podríamos incrustar la versión SPA usando el iframe existente de `CRMContainer` y referenciarlo como un elemento DOM regular, pero el mejor enfoque en React es simplemente eliminar ese componente, reemplazarlo con nuestro propio iframe y referenciarlo mediante una referencia de React (`React Ref`).

```javascript
/* ... */

export default class FeathercorpPlugin extends FlexPlugin {
  constructor() {
    super(PLUGIN_NAME);
    // ref para nuestro iframe personalizado del CRM
    this.crmRef = React.createRef();
  }

  // Función auxiliar para enviar mensajes al CRM
  updateCRM(profileId) {
    this.crmRef.current.contentWindow.postMessage(
      { id: profileId },
      'https://duckycrm-7409-dev.twil.io'
    );
  }

  /* ... */
  
  async init(flex, manager) {
  
    /* ... */

    // Eliminar CRMContainer
    flex.AgentDesktopView.Panel2.Content.remove('container');
    // Agregar nuestro propio contenedor iframe con una ref
    flex.AgentDesktopView.Panel2.Content.add(
      <iframe
        key="crmIframe"
        ref={this.crmRef}
        src="https://duckycrm-7409-dev.twil.io/spa.html"
        style={{ height: '100vh' }}
      />
    );

    // Enviar mensaje cada vez que se selecciona una nueva tarea
    flex.Actions.addListener('beforeSelectTask', (payload) => {
      if (
        payload.task &&
        payload.task.attributes &&
        payload.task.attributes.account_number
      ) {
        this.updateCRM(payload.task.attributes.account_number);
      }
      // No se encontró un número de cuenta
      else {
        this.updateCRM(null);
      }
    });
  }

  /* ... */
}
```

- **Línea 7**: Referencia de React que usaremos para referenciar el nuevo iframe.
- **Líneas 11-16**: Función auxiliar que usa esta referencia para enviar un mensaje al iframe.
- **Línea 14**: Llamada al método `postMessage()`; el primer parámetro representa los datos que se enviarán; el segundo parámetro representa la URL de `targetOrigin`, es decir, el dominio al que se permitirá enviar estos mensajes.
- **Línea 25**: Eliminación del componente `CRMContainer` predeterminado.
- **Líneas 27-34**: Agregar nuestro propio iframe y asociarlo con la referencia `crmRef` definida anteriormente.
- **Línea 31**: URL del CRM que se incrustará en el iframe.
- **Líneas 37-49**: Escuchador `beforeSelectTask` que se activa cada vez que se selecciona una tarea en la UI de Flex. Verifica si los atributos de la tarea contienen `account_number` y, de ser así, llama a la función auxiliar `updateCRM`.

Prueba el código anterior. Debería verse así cuando no hay tareas seleccionadas:

![[Pasted image 20250210205510.png]]

Una vez que llega una nueva tarea, deberías ver el CRM mostrar el perfil del cliente sin tener que abrir una nueva URL:

![[Pasted image 20250210205521.png]]

A continuación, intentemos invertir los roles y colocar Flex dentro de un CRM...
