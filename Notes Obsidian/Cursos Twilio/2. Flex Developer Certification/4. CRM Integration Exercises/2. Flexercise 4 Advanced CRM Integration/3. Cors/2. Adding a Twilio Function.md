En esta lección, crearemos y desplegaremos una **Función de Twilio** a través de la consola web de Twilio. Esta función actuará como un **proxy** entre nuestro plugin de Flex y el CRM al obtener las preguntas de seguridad de un cliente.

Añadiremos más funcionalidad a este proxy en el próximo **Flexercise**. Por ahora, actuará únicamente como un proxy que, además, soluciona los problemas de CORS mencionados anteriormente (la función se ejecuta en el backend, no en un navegador, por lo que no está sujeta a CORS).

Esto evita el mecanismo de CORS de una manera no segura, pero ten paciencia, ya que es solo una solución temporal. En el próximo Flexercise, ampliaremos la función y añadiremos controles de seguridad adecuados.

---

### Consultando el CRM

StorkCRM devuelve las preguntas de seguridad a través de su endpoint `/json` especificando un parámetro `content=sq`, por ejemplo:

```
https://storkcrm-3329-dev.twil.io/json?content=sq&id=543
```

Para obtener las preguntas de seguridad desde StorkCRM, nuestra función utilizará el siguiente código:

```javascript
const fetch = require('node-fetch');
const crmUrl = 'https://storkcrm-3329-dev.twil.io';

exports.handler = function (context, event, callback) {
  let response = new Twilio.Response();

  // '*' permite ser llamado desde cualquier origen, esto no es la mejor práctica
  // de seguridad y solo debe usarse para pruebas; al construir un plugin
  // de producción, debes establecer el origen permitido en
  // 'https://flex.twilio.com' (o cualquier dominio personalizado que sirva el plugin)
  response.appendHeader('Access-Control-Allow-Origin', '*');
  response.appendHeader('Access-Control-Allow-Methods', 'OPTIONS GET');
  response.appendHeader('Access-Control-Allow-Headers', 'Content-Type');

  if (isNaN(event.id)) {
    response.setBody(`Falta el parámetro 'id'.`);
    response.setStatusCode(400);
    return callback(null, response);
  }

  fetch(`${crmUrl}/json?content=sq&id=${event.id}`)
    .then((data) => data.json())
    .then((data) => {
      response.appendHeader('Content-Type', 'application/json');
      response.setBody(data);
      return callback(null, response);
    })
    .catch((err) => {
      console.error('Error en la solicitud: ', err);
      response.setBody('Error en la solicitud');
      response.setStatusCode(500);
      return callback(null, response);
    });
};
```

Esta función recibe una solicitud HTTP, valida que haya un parámetro `id` con un valor numérico, obtiene las preguntas de seguridad para ese `id` desde StorkCRM y las devuelve al cliente.

Pero antes de profundizar y crear algo, echemos un vistazo rápido a las **Funciones de Twilio**.

---

### Funciones de Twilio

**Twilio Functions** es un entorno serverless basado en Node.js que te permite ejecutar tu código en la infraestructura de Twilio. Tú desarrollas el código, y nosotros nos encargamos de la ejecución, escalabilidad y seguridad.

#### Beneficios clave de las Funciones:
- **Serverless**: Descarga la carga operativa a Twilio y evita mantener infraestructura.
- **Seguro**: Si es necesario, puedes asegurar que solo las solicitudes desde el backend de Twilio ejecuten tu función.
- **Escalabilidad automática**: Añade capacidad automáticamente para satisfacer la demanda única de tu aplicación.
- **Integración nativa con Twilio**.

---

### Un vistazo más cercano a una Función

Si observas el fragmento de código anterior, notarás que la función toma tres parámetros:

1. **context**: Este objeto contiene datos de tiempo de ejecución, incluyendo variables de entorno.
2. **event**: Cualquier parámetro HTTP enviado a la función estará en el objeto `event`.
3. **callback**: Usas esta función para enviar una respuesta al cliente.

Es importante destacar que no devuelves una respuesta directamente al cliente. En su lugar, debes devolver una invocación de la función `callback`. En caso de error, puedes pasar un mensaje de error al callback; de lo contrario, devuélvelo con un argumento `null` (indicando que no hubo error) y un mensaje de éxito. Si la función no invoca el callback, eventualmente se agotará el tiempo de espera con un error.

Como buena práctica, recomendamos devolver el callback, aunque es opcional. Lo importante es invocar la función `callback`.
![[Pasted image 20250213212004.png]]

> Error
	Invocar la devolución de llamada con un único argumento que es el mensaje de error

> Éxito
	Si la función se completa correctamente, invoca la devolución de llamada con dos argumentos: un valor nulo (que indica éxito) y un mensaje de respuesta.
---

### Creando una Función de Twilio desde la consola

¡Ahora creemos tu nueva función! En el menú de **Productos y Servicios** de la consola de Twilio, desplázate hacia abajo hasta la sección **Runtime** y haz clic en el ícono de **Funciones** para abrir la página de resumen de Funciones.

#### 1. Crear un servicio para la función
Antes de crear una función, necesitamos crear un **servicio**. Un servicio es una forma de agrupar funciones bajo un nombre de dominio. Haz clic en el botón **"Crear Servicio"**. Se te pedirá que des un nombre al servicio, que formará parte del nombre de dominio para tu servicio y sus funciones. Llamemos al servicio `"test-service"`.
![[Pasted image 20250213212123.png]]
#### 2. La página del Editor de Funciones
Después de crear el servicio, llegarás a la página del **Editor de Funciones**. Observa que el dominio de la función se muestra arriba del botón **"Deploy All"**, por ejemplo:

```
test-service-2655.twil.io
```

(En tu caso, los números en el dominio creado serán diferentes).
![[Pasted image 20250213212131.png]]
#### 3. Crear la función
Una vez creado el servicio, puedes comenzar a añadir funciones. Al hacer clic en **"Add"**, verás algunas opciones. Como vamos a crear y editar la función directamente en la consola, selecciona la primera opción: **"Add function"** y presiona Enter.

Verás una nueva función predeterminada creada en el editor.
![[Pasted image 20250213212139.png]]
#### 4. Editar la ruta de la función
Observa que la ruta de la función por defecto es `/path_1`, que formará parte de la URL de la función. Queremos actualizarla a algo más significativo. Haz clic en los puntos circulados a la derecha del nombre de la función y selecciona **"Rename"** en el menú desplegable. Luego, edita la ruta a `"/crm-proxy"` y presiona Enter.

Una vez cambiada la ruta, nuestra función se podrá ejecutar a través de la URL:

```
https://test-service-2655.twil.io/crm-proxy
```

Puedes copiar la URL de la función usando el menú desplegable o haciendo clic en el enlace **"Copy URL"** en la parte inferior derecha del panel del editor.
![[Pasted image 20250213212147.png]]
#### 5. Actualizar la función
Reemplaza el código predeterminado con el código del fragmento `crm-proxy` mostrado al inicio de esta página.

Una vez copiado y pegado el código, guarda la función.
![[Pasted image 20250213212455.png]]

#### 6. Añadir una dependencia
El código que has copiado depende de la librería `node-fetch`. Para añadir una dependencia, haz clic en **"Dependencies"** en el panel de **"Settings"**.

Añade `node-fetch` y, como la versión 3 de este módulo no se puede importar mediante `require`, asegúrate de fijar la versión a **2**.
![[Pasted image 20250213212512.png]]
#### 7. Hacer la función pública
![[Pasted image 20250213212154.png]]
Las funciones tienen una visibilidad predeterminada de **Protegida**, lo que significa que cualquier solicitud requerirá una firma válida de Twilio para ser accedida. Solo las solicitudes originadas desde la infraestructura de Twilio tendrán los encabezados y firma correctos.

Necesitamos que la función sea accesible desde nuestro plugin. Ese plugin se ejecutará en el escritorio del agente, por lo que la solicitud a nuestra función vendrá desde allí (y no desde la infraestructura de Twilio). Para facilitar esto, modifica la visibilidad a **"Pública"** usando el menú desplegable junto a la etiqueta **"Protected"** en la interfaz.

Más información sobre la visibilidad y acceso de las funciones está disponible [aquí](https://www.twilio.com/docs/runtime/functions/access).

---

### Desplegar y probar la función

Ahora que has realizado los cambios anteriores, estás listo para desplegar la función haciendo clic en el botón **"Deploy All"**.

Una vez completado el despliegue, la función estará accesible para tu plugin de Flex en la URL que vimos anteriormente. Prueba consultar esa URL con `curl` o en un navegador, y no olvides pasar un parámetro `id` numérico. Deberías recibir un objeto JSON con dos preguntas de seguridad.

```bash
$ curl "https://test-service-4724.twil.io/crm-proxy?id=543"
{
  "security_questions": {
    "q1": "¿Cuál es el nivel más alto de educación que has alcanzado?",
    "a1": "Nirvana",
    "q2": "¿Quién es tu personaje favorito de Star Wars?",
    "a2": "Spock"
  }
}
```

---

![[Pasted image 20250213212628.png]]

Para resumir, en esta lección mostramos cómo:

- Crear un servicio para agrupar funciones
- Usar la consola para crear una nueva función y darle una ruta
- Actualizar la función predeterminada y agregar una dependencia
- Hacer pública una función
- E implementar una función

