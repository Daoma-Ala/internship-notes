Aqu√≠ tienes el texto traducido al espa√±ol, listo para pegar en una nota de Obsidian:

---

Ahora, agreguemos la funcionalidad de **fetch** a nuestro plugin.

¬øRecuerdas los √∫ltimos dos archivos en la carpeta **CustomCRM** que pasamos por alto en el recorrido del c√≥digo del plugin?

```
# src/
FeathercorpFx4Plugin.js      # archivo principal del plugin
FeatherCorpTheme.js          # tema de colores del plugin

# src/components/CustomCRM
Common.Styles.js             # estilos de componentes compartidos
CustomCRM.js                 # archivo principal del componente CRM
CustomCRM.Styles.js          # estilos del componente CRM
SecurityQuestions.jsx        # (ignorar por ahora)
SecurityQuestions.Styles.js  # (ignorar por ahora)
```

Esos archivos contienen un componente preconstruido que obtiene y muestra las dos preguntas de seguridad.

Veamos c√≥mo funciona. Primero, aqu√≠ est√° el objeto JSON con las preguntas de seguridad devueltas por StorkCRM:

```json
{
  "security_questions": {
    "q1": "¬øCu√°l es el nivel m√°s alto de educaci√≥n que has alcanzado?",
    "a1": "Nirvana",
    "q2": "¬øQui√©n es tu personaje favorito de Star Wars?",
    "a2": "Spock"
  }
}
```

Las preguntas de seguridad se almacenar√°n en el **estado** del componente.

Inicialmente, el estado es `undefined`, y si ese es el caso, se muestra un bot√≥n **"Mostrar"**:
![[Pasted image 20250213213213.png]]
```javascript
// por defecto, muestra el bot√≥n "Mostrar"
case 'undefined':
  return (
    <SqContainer>
      {header}
      <SqButton onClick={this.getSecQuestions}>Mostrar</SqButton>
    </SqContainer>
  );
```

Cuando un agente presiona el bot√≥n, el plugin utiliza la funci√≥n auxiliar `getSecQuestions()` para obtener las preguntas de seguridad desde la funci√≥n proxy (l√≠nea 40) y actualizar el estado (l√≠nea 52), lo que luego vuelve a renderizar el componente.
![[Pasted image 20250213213223.png]]
```javascript
// obtiene las preguntas de seguridad usando la funci√≥n de Twilio como proxy
getSecQuestions() {
  this.setState({ questions: 'Cargando...' });
  // primero, verifica si el n√∫mero de cuenta se proporciona a trav√©s de los atributos de la tarea
  if (
    this.props.task &&
    this.props.task.attributes &&
    this.props.task.attributes.account_number
  ) {
    // si hay un n√∫mero de cuenta, obt√©n las preguntas de seguridad
    fetch(/* inserta la URL de la funci√≥n proxy + ID del perfil aqu√≠ */)
      .then((response) => {
        if (response.ok) {
          return response.json();
        } else {
          // lanza un error si recibimos alg√∫n error de la funci√≥n
          console.error('Error al obtener del CRM, respuesta:', response);
          throw new Error('Error al obtener del CRM');
        }
      })
      .then((questions) => {
        // guarda las preguntas obtenidas en el estado del componente
        this.setState({ questions: questions.security_questions });
      })
      .catch((error) => {
        // maneja errores recibidos de la funci√≥n o del fetch
        console.error('Error en la solicitud al CRM', error);
        this.setState({
          questions: `Error: No se pudieron obtener las preguntas del CRM.`
        });
      });
  } else {
    this.setState({ questions: 'Error: N√∫mero de cuenta no encontrado' });
  }
}
```

El JSX que renderiza las dos preguntas se ve as√≠:

```javascript
return (
  <SqContainer>
    {header}
    <SqGrid>
      {this.state.questions.q1 && this.state.questions.a1 && (
        <div>
          <SqQuestion>{this.state.questions.q1}</SqQuestion>
          <Value>{this.state.questions.a1}</Value>
        </div>
      )}
      {this.state.questions.q2 && this.state.questions.a2 && (
        <div>
          <SqQuestion>{this.state.questions.q2}</SqQuestion>
          <Value>{this.state.questions.a2}</Value>
        </div>
      )}
    </SqGrid>
  </SqContainer>
);
```

Ahora, tu tarea final. Nada de lo que hemos mostrado en las capturas de pantalla anteriores est√° funcionando actualmente en tu plugin.

Necesitar√°s hacer dos cosas para que funcione:

1. **Completa la URL de tu funci√≥n** y pasa el par√°metro `id` con el ID del perfil del cliente.
2. **Agrega el componente `SecurityQuestions`** al componente `CustomCRM` para que se renderice realmente. No necesitas pasarle ninguna propiedad, el componente es consciente de la tarea y el tema.

Int√©ntalo ahora, y si deseas una pista, aqu√≠ tienes una...

---

### Pista

La URL de tu funci√≥n se puede obtener desde la **Consola de Twilio**. Cuando abres tu funci√≥n, puedes hacer clic en el bot√≥n **"Copiar URL"** o tomar la URL de tu dominio y agregarle la ruta de tu funci√≥n.

El ID del perfil del cliente se puede acceder usando esta variable:

```javascript
this.props.task.attributes.account_number
```

Y un buen lugar para insertar el componente `SecurityQuestions` ser√≠a justo despu√©s de que se rendericen los detalles del perfil, aqu√≠:

```javascript
} else {
  // la tarea est√° seleccionada y los datos del perfil est√°n presentes
  content = (
    <ProfileCanvas>
      <ProfilePhoto
        alt=""
        src={CRM_baseurl + task.attributes.account_data.img_src}
      />
      <HeaderLine>
        <Header>
          <Value>Perfil del Cliente</Value>
        </Header>
      </HeaderLine>
      <LargeCaption>
        {task.attributes.account_data.first_name +
          ' ' +
          task.attributes.account_data.last_name}
      </LargeCaption>
      {profileDetails}
    </ProfileCanvas>
  );
}

return <CustomCRMContainer>{content}</CustomCRMContainer>;
```

---

### Soluci√≥n

Esperamos que ahora tengas todo lo necesario para que el plugin funcione. Puedes comparar tu soluci√≥n con la nuestra a continuaci√≥n...

La URL exacta de la funci√≥n obviamente ser√° diferente en tu caso, pero deber√≠a verse algo as√≠:

```javascript
// si hay un n√∫mero de cuenta, obt√©n las preguntas de seguridad
const crmProxyUrl = 'https://test-service-2655.twil.io/crm-proxy';
fetch(`${crmProxyUrl}?id=${this.props.task.attributes.account_number}`)
  .then((response) => {
```

Y el componente `SecurityQuestions` se puede agregar al `CustomCRM`, por ejemplo, as√≠:

```javascript
<LargeCaption>
  {task.attributes.account_data.first_name +
    ' ' +
    task.attributes.account_data.last_name}
</LargeCaption>
{profileDetails}
<SecurityQuestions />
</ProfileCanvas>
```

Si ahora intentas iniciar tu plugin, llamar y hacer clic para mostrar las preguntas de seguridad del cliente, deber√≠as ver algo como esto:

---
![[Pasted image 20250213213245.png]]
¬°Felicidades! Ahora tienes un plugin funcional que muestra datos de un CRM utilizando componentes personalizados. Puedes usar las t√©cnicas discutidas en este curso para mostrar datos de m√∫ltiples fuentes en la interfaz de Flex y proporcionar a tus agentes una visi√≥n hol√≠stica.

Por √∫ltimo, pero no menos importante, hemos ignorado por completo la seguridad de esta soluci√≥n hasta ahora. StorkCRM no restringe el acceso de ninguna manera, la funci√≥n que construimos puede ser invocada por casi cualquier persona, todos los agentes tienen el mismo nivel de acceso, etc. Esto obviamente no ser√° suficiente para ning√∫n entorno de producci√≥n, por lo que en el pr√≥ximo **Flexercise** abordaremos estas deficiencias.

Pero antes de llegar all√≠, por favor dinos qu√© funcion√≥ y qu√© no...

---

Espero que esto te sea √∫til para tu nota en Obsidian. üòä