# Manejo de reservas rechazadas en TaskRouter

Este módulo asume que tienes un conocimiento funcional de TaskRouter. Si aún no has trabajado con TaskRouter, podría ser un buen momento para revisar nuestro curso **Fundamentos de TaskRouter**.

Un problema común que los usuarios reportan es un comportamiento algo inesperado después de rechazar reservas.

Supongamos que acabas de configurar tu primer proyecto de Flex, inicias sesión con un agente de prueba y llamas al número de teléfono que hemos provisionado automáticamente para ti. La tarea se crea, tu agente ve la reserva, la acepta, la tarea se conecta y puedes escuchar tu primer "prueba, prueba..." pasar. Hasta aquí, todo está bien.

Ahora comienzas a experimentar un poco más. Y muy pronto, probablemente pensarás: *"Déjame rechazar la reserva y ver qué sucede"*. Podrías esperar que la reserva desaparezca después de rechazarla. Y, de hecho, la reserva desaparecerá momentáneamente, pero luego volverá inmediatamente y tu agente será reservado nuevamente para la misma tarea.

Antes de continuar, intenta responder:

**¿Por qué está sucediendo esto?**

Como habrás concluido, TaskRouter no tiene otra opción. En esta configuración de prueba, tu agente es el único agente disponible. Por lo tanto, después de que la tarea se devuelve al Workflow, siempre terminará seleccionando el mismo Worker, simplemente porque es el único disponible y no tenemos ninguna lógica para rastrear si ya han rechazado esta tarea.

---

## Solución

La situación que hemos descrito no es necesariamente problemática. Una vez que agregues múltiples agentes a tu Centro de Contacto, esto probablemente se resolverá por sí solo. Cuando hay varios agentes elegibles para recibir una tarea, después de rechazar una reserva, otro agente será seleccionado automáticamente.

Sin embargo, es posible que aún desees resolver esta situación para casos en los que las **TaskQueues** estén altamente utilizadas y a menudo solo haya un solo agente disponible.

Para abordar esto, puedes agregar un atributo a la tarea que rastree los SIDs de los Workers que la han rechazado hasta el momento. Llamemos a este atributo `rejected_workers`.

Luego, en el Workflow, puedes usar una **Expresión de Worker Objetivo** que excluya a los Workers cuyos SIDs estén en la lista `rejected_workers`.

El plugin que llena el atributo `rejected_workers` de la tarea podría verse así:

```javascript
// Ejemplo de plugin para agregar rejected_workers
manager.workerClient.on("reservationRejected", (reservation) => {
  const task = reservation.task;
  const workerSid = manager.workerClient.sid;

  if (!task.attributes.rejected_workers) {
    task.attributes.rejected_workers = [];
  }

  if (!task.attributes.rejected_workers.includes(workerSid)) {
    task.attributes.rejected_workers.push(workerSid);
    task.updateAttributes(task.attributes);
  }
});
```

Y el Workflow que coincide con esto podría verse, por ejemplo, así:

![[Pasted image 20250225113253.png]]

Nota que aquí hemos creado dos **Filtros**:
1. Uno para coincidir con tareas que aún no tienen ningún `rejected_workers` establecido.
2. Otro para coincidir con tareas que sí tienen `rejected_workers`.

En el segundo filtro, estamos configurando la **Expresión de Worker Objetivo** como:

```plaintext
worker.sid NOT IN task.rejected_workers
```

Esto excluirá a los Workers cuyos SIDs estén en la lista `rejected_workers`.

Ambos filtros envían las tareas a la misma **TaskQueue**, pero en el caso del segundo filtro, los Workers de esa cola que ya hayan rechazado la tarea no serán elegibles para recibirla, y la tarea permanecerá en estado **Pending** hasta que otro Worker esté disponible.

Aquí hay un ejemplo de una tarea que ha sido rechazada por 3 Workers diferentes:

![[Pasted image 20250225113303.png]]

Nota el atributo `rejected_workers` de la tarea y el estado actual de la asignación de la tarea. (Los atributos de la tarea se han formateado para una mejor legibilidad).

# Preguntas y respuestas sobre el manejo de tareas rechazadas

## Pregunta 1
**¿Por qué la tarea en el ejemplo anterior está en el estado de asignación pendiente (pending assignment)?**

### Respuesta 1
Porque, aparte de los 3 agentes que ya han rechazado la tarea, probablemente no hay otros agentes disponibles en la cola **"Everyone"**. La tarea permanece en estado **Pending** hasta que otro agente elegible esté disponible para aceptarla.

---

## Pregunta 2
![[Pasted image 20250225113423.png]]

Al probar la configuración anterior, intentamos rechazar las reservas de tareas directamente desde la **Consola de Twilio** utilizando el botón **Reject** resaltado en la captura de pantalla.

Pero cuando una tarea se rechaza de esta manera, el atributo `rejected_workers` no se actualiza y el mismo Worker puede recibir múltiples reservas para la misma tarea.

**¿Por qué sucede esto?**

### Respuesta 2
Si recuerdas, estamos actualizando el atributo `rejected_workers` en nuestro **plugin de Flex UI** sobrescribiendo la acción **RejectTask** de la interfaz de usuario de Flex.

Sin embargo, cuando rechazas la reserva desde la **Consola de Twilio**, la interfaz de usuario de Flex no está involucrada, y el rechazo ocurre únicamente a nivel de **TaskRouter**. Como resultado, el plugin no se activa y el atributo `rejected_workers` no se actualiza, lo que permite que el mismo Worker reciba múltiples reservas para la misma tarea.
