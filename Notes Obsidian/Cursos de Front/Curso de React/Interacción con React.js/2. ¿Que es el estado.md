# ğŸ”¹ Estado en React (`useState`)

El **Estado** es una de las herramientas principales en React para crear interfaces dinÃ¡micas y actualizadas en tiempo real.

## ğŸ“Œ Â¿QuÃ© es el Estado?

Podemos definir el estado como **"variables que almacenan informaciÃ³n dinÃ¡mica de un componente y que se actualizan a medida que el usuario interactÃºa con la UI"**.

El estado permite:

- Mantener la informaciÃ³n actualizada sin necesidad de renderizar todo el componente.
- Cambiar la apariencia y el comportamiento de un componente en tiempo real.
- Optimizar actualizaciones mediante el **Virtual DOM**, que compara los cambios y actualiza solo lo necesario.

---

## ğŸŸ¢ `useState` en React

El hook `useState` es la forma mÃ¡s comÃºn de manejar estado en React.

ğŸ”¹ **Retorna un array con dos valores**:

1. **El estado actual**.
2. **Una funciÃ³n para actualizarlo** (por convenciÃ³n, empieza con `set`).

Ejemplo sin desestructuraciÃ³n:

```jsx
function Component () {
  const state = useState("valor inicial");
  const searchValue = state[0];  
  const setSearchValue = state[1];

  return <div> ... </div>;
}
```

Ejemplo con desestructuraciÃ³n (mÃ¡s limpio y comÃºn en React):

```jsx
function Component () {
  const [searchValue, setSearchValue] = useState("valor inicial");

  return <div> ... </div>;
}
```

---

## ğŸ”„ Â¿CuÃ¡ndo se renderiza un componente en React?

Un componente se vuelve a renderizar cuando:

1. **Su estado cambia** (cuando usamos `setState`).
2. **Sus props cambian**.

âš ï¸ **React vuelve a ejecutar toda la funciÃ³n del componente**, incluyendo hooks, variables y funciones, **pero el `useState` solo se inicializa una vez** en la vida del componente.

---

## âš¡ï¸ La actualizaciÃ³n del estado es **asÃ­ncrona**

Si actualizamos el estado varias veces seguidas, React no aplicarÃ¡ cada cambio inmediatamente, sino que agruparÃ¡ las actualizaciones.

Ejemplo incorrecto:

```jsx
const [counter, setCounter] = useState(0);

function handleCounter () {
  setCounter(counter + 3);
  setCounter(counter + 3);
  setCounter(counter + 3);
}
```

ğŸ’¡ **Â¿CuÃ¡l serÃ¡ el nuevo valor de `counter` despuÃ©s de llamar `handleCounter()`?**  
ğŸ”¹ **Respuesta: 3** (no 9), porque React solo considera el Ãºltimo estado disponible al momento de la actualizaciÃ³n.

ğŸ”¹ **SoluciÃ³n:**  
Para asegurarnos de que cada actualizaciÃ³n tenga en cuenta el valor actualizado, pasamos una **funciÃ³n que recibe el estado anterior**.

```jsx
function handleCounter () {
  setCounter(prevCounter => prevCounter + 3);
  setCounter(prevCounter => prevCounter + 3);
  setCounter(prevCounter => prevCounter + 3);
}
```

âœ… Ahora el valor final de `counter` serÃ¡ **9**, porque cada actualizaciÃ³n se basa en el estado mÃ¡s reciente.

---

## ğŸš€ Consideraciones Finales

- **Siempre usa `setState` correctamente** para evitar renderizados innecesarios.
- **Si el estado depende de su valor anterior, usa funciones en `setState`**.
- **React puede agrupar mÃºltiples actualizaciones de estado** para optimizar la performance.
- **Si necesitas manejar estado global, considera `useReducer` o `context API`** en lugar de `useState`.

| 